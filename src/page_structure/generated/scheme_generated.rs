// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod pager {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLUMN_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLUMN_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLUMN_TYPE: [ColumnType; 2] = [
  ColumnType::Dynamic,
  ColumnType::Identity,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ColumnType(pub u8);
#[allow(non_upper_case_globals)]
impl ColumnType {
  pub const Dynamic: Self = Self(0);
  pub const Identity: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Dynamic,
    Self::Identity,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Dynamic => Some("Dynamic"),
      Self::Identity => Some("Identity"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for ColumnType {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ColumnType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for ColumnType {
    type Output = ColumnType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ColumnType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ColumnType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ColumnType {}
pub enum UnitColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnitColumn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnitColumn<'a> {
    type Inner = UnitColumn<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnitColumn<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnitColumn { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnitColumnArgs<'args>) -> flatbuffers::WIPOffset<UnitColumn<'bldr>> {
      let mut builder = UnitColumnBuilder::new(_fbb);
      builder.add_data_page(args.data_page);
      builder.add_clock_page(args.clock_page);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_id(args.id);
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_CLOCK_PAGE: flatbuffers::VOffsetT = 10;
    pub const VT_DATA_PAGE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(UnitColumn::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UnitColumn::VT_NAME, None)
  }
  #[inline]
  pub fn type_(&self) -> ColumnType {
    self._tab.get::<ColumnType>(UnitColumn::VT_TYPE_, Some(ColumnType::Dynamic)).unwrap()
  }
  #[inline]
  pub fn clock_page(&self) -> u64 {
    self._tab.get::<u64>(UnitColumn::VT_CLOCK_PAGE, Some(0)).unwrap()
  }
  #[inline]
  pub fn data_page(&self) -> u64 {
    self._tab.get::<u64>(UnitColumn::VT_DATA_PAGE, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnitColumn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<ColumnType>(&"type_", Self::VT_TYPE_, false)?
     .visit_field::<u64>(&"clock_page", Self::VT_CLOCK_PAGE, false)?
     .visit_field::<u64>(&"data_page", Self::VT_DATA_PAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitColumnArgs<'a> {
    pub id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: ColumnType,
    pub clock_page: u64,
    pub data_page: u64,
}
impl<'a> Default for UnitColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnitColumnArgs {
            id: 0,
            name: None,
            type_: ColumnType::Dynamic,
            clock_page: 0,
            data_page: 0,
        }
    }
}
pub struct UnitColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnitColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(UnitColumn::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitColumn::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ColumnType) {
    self.fbb_.push_slot::<ColumnType>(UnitColumn::VT_TYPE_, type_, ColumnType::Dynamic);
  }
  #[inline]
  pub fn add_clock_page(&mut self, clock_page: u64) {
    self.fbb_.push_slot::<u64>(UnitColumn::VT_CLOCK_PAGE, clock_page, 0);
  }
  #[inline]
  pub fn add_data_page(&mut self, data_page: u64) {
    self.fbb_.push_slot::<u64>(UnitColumn::VT_DATA_PAGE, data_page, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnitColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnitColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnitColumn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnitColumn<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnitColumn");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("clock_page", &self.clock_page());
      ds.field("data_page", &self.data_page());
      ds.finish()
  }
}
pub enum UnitTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnitTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnitTable<'a> {
    type Inner = UnitTable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnitTable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnitTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnitTableArgs<'args>) -> flatbuffers::WIPOffset<UnitTable<'bldr>> {
      let mut builder = UnitTableBuilder::new(_fbb);
      if let Some(x) = args.columns { builder.add_columns(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UnitTable::VT_NAME, None)
  }
  #[inline]
  pub fn columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitColumn<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitColumn>>>>(UnitTable::VT_COLUMNS, None)
  }
}

impl flatbuffers::Verifiable for UnitTable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UnitColumn>>>>(&"columns", Self::VT_COLUMNS, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitTableArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitColumn<'a>>>>>,
}
impl<'a> Default for UnitTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnitTableArgs {
            name: None,
            columns: None,
        }
    }
}
pub struct UnitTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnitTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitTable::VT_NAME, name);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UnitColumn<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitTable::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnitTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnitTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnitTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnitTable<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnitTable");
      ds.field("name", &self.name());
      ds.field("columns", &self.columns());
      ds.finish()
  }
}
pub enum UnitSchemeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnitScheme<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnitScheme<'a> {
    type Inner = UnitScheme<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnitScheme<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnitScheme { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnitSchemeArgs<'args>) -> flatbuffers::WIPOffset<UnitScheme<'bldr>> {
      let mut builder = UnitSchemeBuilder::new(_fbb);
      if let Some(x) = args.tables { builder.add_tables(x); }
      builder.finish()
    }

    pub const VT_TABLES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn tables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitTable<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitTable>>>>(UnitScheme::VT_TABLES, None)
  }
}

impl flatbuffers::Verifiable for UnitScheme<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UnitTable>>>>(&"tables", Self::VT_TABLES, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitSchemeArgs<'a> {
    pub tables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitTable<'a>>>>>,
}
impl<'a> Default for UnitSchemeArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnitSchemeArgs {
            tables: None,
        }
    }
}
pub struct UnitSchemeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnitSchemeBuilder<'a, 'b> {
  #[inline]
  pub fn add_tables(&mut self, tables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UnitTable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitScheme::VT_TABLES, tables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnitSchemeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnitSchemeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnitScheme<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnitScheme<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnitScheme");
      ds.field("tables", &self.tables());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_unit_scheme<'a>(buf: &'a [u8]) -> UnitScheme<'a> {
  unsafe { flatbuffers::root_unchecked::<UnitScheme<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_unit_scheme<'a>(buf: &'a [u8]) -> UnitScheme<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<UnitScheme<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `UnitScheme`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_unit_scheme_unchecked`.
pub fn root_as_unit_scheme(buf: &[u8]) -> Result<UnitScheme, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<UnitScheme>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `UnitScheme` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_unit_scheme_unchecked`.
pub fn size_prefixed_root_as_unit_scheme(buf: &[u8]) -> Result<UnitScheme, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<UnitScheme>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `UnitScheme` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_unit_scheme_unchecked`.
pub fn root_as_unit_scheme_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<UnitScheme<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<UnitScheme<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `UnitScheme` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_unit_scheme_unchecked`.
pub fn size_prefixed_root_as_unit_scheme_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<UnitScheme<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<UnitScheme<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a UnitScheme and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `UnitScheme`.
pub unsafe fn root_as_unit_scheme_unchecked(buf: &[u8]) -> UnitScheme {
  flatbuffers::root_unchecked::<UnitScheme>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed UnitScheme and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `UnitScheme`.
pub unsafe fn size_prefixed_root_as_unit_scheme_unchecked(buf: &[u8]) -> UnitScheme {
  flatbuffers::size_prefixed_root_unchecked::<UnitScheme>(buf)
}
#[inline]
pub fn finish_unit_scheme_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<UnitScheme<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_unit_scheme_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<UnitScheme<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Pager

